<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.1">
<title>Multi-Protocol Networking Library For C/C++</title>
<style>
@import url('https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic|Noto+Serif:400,400italic,700,700italic|Droid+Sans+Mono:400');

*, *:after, *:before {
  -moz-box-sizing: border-box;
  -webkit-box-sizing: border-box;
  box-sizing: border-box;
  outline: 0;
}

html, body { margin: 0; padding: 0; }

body {
  font: 15px/1.4 'Helvetica Neue', Helvetica, Arial, sans-serif;
  color: #444;
}

a { color: #369; }
li > p { margin: 0; padding: 0; }
dt { font-weight: bold; }
h1, h2 { color: #369; }
h2 { border-bottom: 1px solid #69c; }
code, pre {
  font: 14px/1.0 Courier, 'DejaVu Sans Mono', monospace !important;
}
p > code { background: #f0f0f0; }
pre, pre > code { border-radius: 0.5em; }
pre {  border: 1px solid #ccc;  }

#toc.toc2 {
  position: fixed; width: 20%; left: 0; top: 0;
  border-right: 1px solid #ccc; z-index: 1000;
  height: 100%; overflow: auto; line-height: 1.5em;
}
#toc { background: #eee; }
#toc ul { list-style-type: none; margin-left: 1em; padding: 0; }
#toctitle { margin: 0.5em 1em;}

#content, h1 {
  margin: 1em 3em 0 22%;
}

#footer { margin: 0.2em 1em; font-size: 90%; color: silver; text-align: right; }
</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.1/styles/github.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.1/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</head>
<body class="article toc2 toc-left">
<div id="header">
<h1>Multi-Protocol Networking Library For C/C++</h1>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_concept">Concept</a></li>
<li><a href="#_using_fossa">Using Fossa</a></li>
<li><a href="#_plain_tcp_udp_ssl_api">Plain TCP/UDP/SSL API</a>
<ul class="sectlevel2">
<li><a href="#_structures">Structures</a></li>
<li><a href="#_functions_for_fossa_manager">Functions for Fossa manager</a></li>
<li><a href="#_functions_for_adding_new_connections">Functions for adding new connections</a></li>
<li><a href="#_functions_for_sending_data">Functions for sending data</a></li>
<li><a href="#_utility_functions">Utility functions</a></li>
<li><a href="#_http_websocket_api">HTTP/Websocket API</a></li>
<li><a href="#_json_rpc_api">JSON-RPC API</a></li>
<li><a href="#_mqtt_api">MQTT API</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_concept">Concept</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Fossa is a non-blocking, asyncronous event manager described by
<code>struct ns_mgr</code> structure. That structure holds active connections.
Connections could be either <strong>listening</strong>, <strong>client</strong> or <strong>accepted</strong>.
Client connections are created by
<code>ns_connect()</code> call. Listening connections are created by <code>ns_bind()</code> call.
Accepted connections are those that incoming on a listening connection.
Each connection is described by <code>struct ns_connection</code> structure, which has
a number of fields like socket, event handler function, send/receive buffer,
flags, et cetera.</p>
</div>
<div class="paragraph">
<p><code>ns_mgr_poll()</code> should be called in an infinite event loop.
<code>ns_mgr_poll()</code> iterates over all sockets, accepts new connections,
sends and receives data, closes connections, and calls an event handler
function for each of those events.</p>
</div>
<div class="paragraph">
<p>Each connection has send and receive buffer, <code>struct ns_connection::send_iobuf</code>
and <code>struct ns_connection::recv_iobuf</code> respectively. When data arrives,
Fossa appends received data to the <code>recv_iobuf</code> and
triggers <code>NS_RECV</code> event. User may send data back (<code>ns_send()</code> or
<code>ns_printf()</code>), which appends data to the <code>send_iobuf</code>. When Fossa
successfully writes data to the socket, it discards it from <code>send_iobuf</code> and
sends <code>NS_SEND</code> event. When connection is closed, <code>NS_CLOSE</code> event is sent.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="http://cesanta.com/images/fossa/iobuf.png" alt="iobuf">
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_using_fossa">Using Fossa</h2>
<div class="sectionbody">
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Define an event handler function.</p>
</li>
<li>
<p>Initialize mgr by calling <code>ns_mgr_init()</code>.</p>
</li>
<li>
<p>Create <strong>listening connections</strong> with <code>ns_bind()</code> and/or <strong>client connections</strong>
with <code>ns_connect()</code>. Note that many connections can be created within a
single manager. Connections can be created at any time, including within
an event handler function.</p>
</li>
<li>
<p>Call <code>ns_mgr_poll()</code> in a loop.</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c" data-lang="c">#include "fossa.h"

// This event handler implements TCP echo server
static void ev_handler(struct ns_connection *nc, int ev, void *ev_data) { // 1
  struct iobuf *io = &amp;nc-&gt;recv_iobuf;

  switch (ev) {
    case NS_RECV:
      ns_send(nc, io-&gt;buf, io-&gt;len);  // Echo received data back
      iobuf_remove(io, io-&gt;len);      // Discard data from recv buffer
      break;
    default:
      break;
  }
}

int main(void) {
  struct ns_mgr mgr;
  ns_mgr_init(&amp;mgr, NULL);  // 2
  ns_bind(&amp;mgr, "1234", ev_handler, NULL);  // 3

  // 4 - an event loop
  for (;;) {
    ns_mgr_poll(&amp;mgr, 1000);
  }

  ns_mgr_free(&amp;mgr);
  return 0;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Fossa accepts incoming connections, reads and writes data, and
calls specified event handler for each connection when appropriate. An
event handler should examine received data, set connection flags if needed,
and send data back to the client by <code>ns_send()</code> or <code>ns_printf()</code>. Here is a
typical event flow for the accepted connection:
<code>NS_ACCEPT</code> &#8594; <code>NS_RECV</code> &#8594; &#8230;&#8203;. &#8594; <code>NS_CLOSE</code>. Below is a complete list
of events triggered by Fossa:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">NS_ACCEPT</dt>
<dd>
<p>sent when new server connection is accepted by a
listening connection. <code>void *ev_data</code> is <code>union socket_address</code>
of the remote peer.</p>
</dd>
<dt class="hdlist1">NS_CONNECT</dt>
<dd>
<p>sent when a new client connection created by <code>ns_connect()</code> either
failed or succeeded. <code>void *ev_data</code> is <code>int *success</code>. If <code>success</code> is 0
then connection has been established, otherwise it contains error code. Example
code to check connection status:</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c" data-lang="c">static void ev_handler(struct ns_connection *nc, int ev, void *ev_data) {
  int connect_status;

  switch (ev) {
    case NS_CONNECT:
      connect_status = * (int *) ev_data;
      if (connect_status == 0) {
        /* Success */
      } else  {
        /* Error */
        printf("connect() error: %s\n", strerror(connect_status));
      }
      break;
    ...</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">NS_RECV</dt>
<dd>
<p>New data is received and appended to the end of <code>recv_iobuf</code>.
<code>void *ev_data</code> is <code>int *num_received_bytes</code>.</p>
</dd>
</dl>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<img src="data:image/png;base64,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" alt="Warning">
</td>
<td class="content">
Fossa uses <code>realloc()</code> to expand receive buffer.
It is user&#8217;s responsibility to discard processed
data from the beginning of receive buffer, note the <code>iobuf_remove()</code>
call in the example above.
</td>
</tr>
</table>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">NS_SEND</dt>
<dd>
<p>Fossa has written data to the remote peer and discarded
written data from the <code>send_iobuf</code>. <code>void *ev_data</code> is <code>int *num_sent_bytes</code></p>
</dd>
<dt class="hdlist1">NS_POLL</dt>
<dd>
<p>Sent to all connections on each invocation of <code>ns_server_poll()</code></p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>An event handler can set <code>struct ns_connection::flags</code> attribute to control
the behavior of the connection.  Below is a list of connection flags:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>NSF_FINISHED_SENDING_DATA</code> tells Fossa that all data has been
appended to the <code>send_iobuf</code>. As soon as Fossa sends it to the
socket, the connection will be closed.</p>
</li>
<li>
<p><code>NSF_BUFFER_BUT_DONT_SEND</code> tells Fossa to append data to the
<code>send_iobuf</code> but hold on sending it, because the data will be modified
later and then will be sent by clearing <code>NSF_BUFFER_BUT_DONT_SEND</code> flag.</p>
</li>
<li>
<p><code>NSF_SSL_HANDSHAKE_DONE</code> SSL only, set when SSL handshake is done</p>
</li>
<li>
<p><code>NSF_CONNECTING</code> set when connection is in connecting state after
<code>ns_connect()</code> call but connect did not finish yet</p>
</li>
<li>
<p><code>NSF_CLOSE_IMMEDIATELY</code> tells Fossa to close the connection
immediately, usually after some error</p>
</li>
<li>
<p><code>NSF_LISTENING</code> set for all listening connections</p>
</li>
<li>
<p><code>NSF_UDP</code> set if connection is UDP</p>
</li>
<li>
<p><code>NSF_IS_WEBSOCKET</code> set by Fossa if connection is a Websocket connection</p>
</li>
<li>
<p><code>NSF_WEBSOCKET_NO_DEFRAG</code> should be set by a user if user wants to switch
off automatic frame defragmentation</p>
</li>
<li>
<p><code>NSF_USER_1</code>, <code>NSF_USER_2</code>, <code>NSF_USER_3</code>, <code>NSF_USER_4</code> could be
used by a developer to store application-specific state</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_plain_tcp_udp_ssl_api">Plain TCP/UDP/SSL API</h2>
<div class="sectionbody">
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<img src="data:image/png;base64,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" alt="Caution">
</td>
<td class="content">
Fossa manager instance is single threaded. It does not protect
it&#8217;s data structures by mutexes, therefore all functions that are dealing
with particular event manager should be called from the same thread,
with exception of <code>mg_broadcast()</code> function. It is fine to have different
event managers handled by different threads.
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="_structures">Structures</h3>
<div class="ulist">
<ul>
<li>
<p><code>struct ns_connection</code> Describes a connection between two peers</p>
</li>
<li>
<p><code>struct ns_mgr</code> Container for a bunch of connections</p>
</li>
<li>
<p><code>struct iobuf</code> Describes piece of data</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_functions_for_fossa_manager">Functions for Fossa manager</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">void ns_mgr_init(struct ns_mgr *, void *user_data)</dt>
<dd>
<p>Initializes Fossa manager.</p>
</dd>
<dt class="hdlist1">void ns_mgr_free(struct ns_mgr *)</dt>
<dd>
<p>De-initializes skeleton manager, closes and deallocates all active connections.</p>
</dd>
<dt class="hdlist1">time_t ns_mgr_poll(struct ns_mgr *, int milliseconds)</dt>
<dd>
<p>This function performs the actual IO, and must be called in a loop
(an event loop). Returns number current timestamp.</p>
</dd>
<dt class="hdlist1">void ns_broadcast(struct ns_mgr *, ns_event_handler_t cb, void *msg, size_t len)</dt>
<dd>
<p>Must be called from a different thread. Passes a message of a given length to
all connections. Skeleton manager has a socketpair, <code>struct ns_mgr::ctl</code>,
where <code>ns_broadcast()</code> pushes the message.
<code>ns_mgr_poll()</code> wakes up, reads a message from the socket pair, and calls
specified callback for each connection. Thus the callback function executes
in event manager thread. Note that <code>ns_broadcast()</code> is the only function
that can be, and must be, called from a different thread.</p>
</dd>
<dt class="hdlist1">void ns_next(struct ns_mgr *, struct ns_connection *)</dt>
<dd>
<p>Iterates over all active connections. Returns next connection from the list
of active connections, or <code>NULL</code> if there is no more connections. Below
is the iteration idiom:</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c" data-lang="c">for (c = ns_next(srv, NULL); c != NULL; c = ns_next(srv, c)) {
  // Do something with connection `c`
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_functions_for_adding_new_connections">Functions for adding new connections</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">struct ns_connection *ns_add_sock(struct ns_mgr *, sock_t sock, ns_event_handler_t ev_handler)</dt>
<dd>
<p>Create a connection, associate it with the given socket and event handler, and
add to the manager.</p>
</dd>
<dt class="hdlist1">struct ns_connection *ns_connect(struct ns_mgr *server, const char *addr, ns_event_handler_t ev_handler)</dt>
<dd>
<p>Connect to a remote host. If successful, <code>NS_CONNECT</code> event will be delivered
to the new connection. <code>addr</code> format is the same as for the <code>ns_bind()</code> call,
just an IP address becomes mandatory: <code>[PROTO://]HOST:PORT</code>
<code>PROTO</code> could be <code>tcp://</code> or <code>udp://</code>. If <code>HOST</code> is not an IP
address, Fossa will resolve it - beware that standard blocking resolver
will be used. It is a good practice to pre-resolve hosts beforehands and
use only IP addresses to avoid blockin an IO thread.
Returns: new client connection, or <code>NULL</code> on error.</p>
</dd>
<dt class="hdlist1">struct ns_connection *ns_bind(struct ns_mgr *, const char *addr, ns_event_handler_t ev_handler)</dt>
<dd>
<p>Start listening on the given port. <code>addr</code> could be a port number,
e.g. <code>"3128"</code>, or IP address with a port number, e.g. <code>"127.0.0.1:3128"</code>.
Also, a protocol prefix could be specified, valid prefixes are <code>tcp://</code> or
<code>udp://</code>.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Note that for UDP listening connections, only <code>NS_RECV</code> and <code>NS_CLOSE</code>
are triggered.</p>
</div>
<div class="paragraph">
<p>If IP address is specified, Fossa binds to a specific interface only.
Also, port could be <code>"0"</code>, in which case a random non-occupied port number
will be chosen. Return value: a listening connection on success, or
<code>NULL</code> on error.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">const char *ns_set_ssl(struct ns_connection *nc, const char *cert, const char *ca_cert)</dt>
<dd>
<p>Enable SSL for a given connection. Connection must be TCP. For listening
connection, <code>cert</code> is a path to a server certificate, and is mandatory.
<code>ca_cert</code> if non-NULL, specifies CA certificate for client authentication,
enables two-way SSL. For client connections, both <code>cert</code> and <code>ca_cert</code> are
optional and can be set to NULL. All certificates
must be in PEM format. PEM file for server certificate should contain
both certificate and the private key concatenated together.
Returns: NULL if there is no error, or error string if there was error.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Snippet below shows how to generate self-signed SSL certificate using OpenSSL:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh" data-lang="sh">openssl req -x509 -nodes -newkey rsa:2048 -keyout key.pem -out cert.pem -days 365
cat cert.pem key.pem &gt; my_ssl_cert.pem</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_functions_for_sending_data">Functions for sending data</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">int ns_send(struct ns_connection *, const void *buf, int len)</dt>
<dt class="hdlist1">int ns_printf(struct ns_connection *, const char *fmt, &#8230;&#8203;)</dt>
<dt class="hdlist1">int ns_vprintf(struct ns_connection *, const char *fmt, va_list ap)</dt>
<dd>
<p>These functions are for sending un-formatted and formatted data to the
connection. Number of written bytes is returned. Note that these sending
functions do not actually push data to the sockets, they just append data
to the output buffer. The exception is UDP connections. For UDP, data is
sent immediately, and returned value indicates an actual number of bytes
sent to the socket.</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_utility_functions">Utility functions</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">void *ns_start_thread(void *(*thread_function)(void *), void *param)</dt>
<dd>
<p>Starts a new thread</p>
</dd>
<dt class="hdlist1">int ns_socketpair2(sock_t [2], int proto)</dt>
<dd>
<p>Create a socket pair. <code>proto</code> can be either <code>SOCK_STREAM</code> or <code>SOCK_DGRAM</code>.
Return 0 on failure, 1 on success.</p>
</dd>
<dt class="hdlist1">void ns_set_close_on_exec(sock_t)</dt>
<dd>
<p>Set close-on-exec bit for a given socket.</p>
</dd>
<dt class="hdlist1">void ns_sock_to_str(sock_t sock, char *buf, size_t len, int flags)</dt>
<dd>
<p>Converts socket&#8217;s local or remote address into string. <code>flags</code> parameter
is a bit mask that controls the behavior. If bit 2 is set (<code>flags &amp; 4</code>) then
the remote address is stringified, otherwise local address is stringified.
If bit 0 is set, then IP
address is printed. If bit 1 is set, then port number is printed. If both
port number and IP address are printed, they are separated by <code>:</code>.</p>
</dd>
<dt class="hdlist1">int ns_hexdump(const void *buf, int len, char *dst, int dst_len)</dt>
<dd>
<p>Takes a memory buffer <code>buf</code> of length <code>len</code> and creates a hex dump of that
buffer in <code>dst</code>.</p>
</dd>
<dt class="hdlist1">int ns_resolve(const char *domain_name, char *ip_addr_buf, size_t buf_len)</dt>
<dd>
<p>Converts domain name into IP address. This is a blocking call. Returns 1
on success, 0 on failure.</p>
</dd>
<dt class="hdlist1">int ns_stat(const char *path, ns_stat_t *st)</dt>
<dd>
<p>Perform a 64-bit <code>stat()</code> call against given file. <code>path</code> should be
UTF8 encoded. Return value is the same as for <code>stat()</code> syscall.</p>
</dd>
<dt class="hdlist1">FILE *ns_fopen(const char *path, const char *mode)</dt>
<dd>
<p>Open given file and return a file stream. <code>path</code> and <code>mode</code> should be
UTF8 encoded. Return value is the same as for <code>fopen()</code> call.</p>
</dd>
<dt class="hdlist1">int ns_open(const char *path, int flag, int mode)</dt>
<dd>
<p>Open given file and return file descriptor. <code>path</code> should be UTF8 encoded.
Return value is the same as for <code>open()</code> syscall.</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_http_websocket_api">HTTP/Websocket API</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">void ns_set_protocol_http_websocket(struct ns_connection *)</dt>
<dd>
<p>Attach built-in HTTP event handler to the given connection. User-defined
event handler will receive following extra events:</p>
<div class="ulist">
<ul>
<li>
<p>NS_HTTP_REQUEST: HTTP request has arrived. Parsed HTTP request is passed as
<code>struct http_message</code> through the handler&#8217;s <code>void *ev_data</code> pointer.</p>
</li>
<li>
<p>NS_HTTP_REPLY: HTTP reply has arrived. Parsed HTTP reply is passed as
<code>struct http_message</code> through the handler&#8217;s <code>void *ev_data</code> pointer.</p>
</li>
<li>
<p>NS_WEBSOCKET_HANDSHAKE_REQUEST: server has received websocket handshake
request. <code>ev_data</code> contains parsed HTTP request.</p>
</li>
<li>
<p>NS_WEBSOCKET_HANDSHAKE_DONE: server has completed Websocket handshake.
<code>ev_data</code> is <code>NULL</code>.</p>
</li>
<li>
<p>NS_WEBSOCKET_FRAME: new websocket frame has arrived. <code>ev_data</code> is
<code>struct websocket_message *</code></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">void ns_send_websocket_handshake(struct ns_connection *nc, const char *uri, const char *extra_headers)</dt>
<dd>
<p>Sends websocket handshake to the server. <code>nc</code> must be a valid connection, connected to a server, <code>uri</code> is an URI on the server, <code>extra_headers</code> is
extra HTTP headers to send or <code>NULL</code>.
This function is to be used by websocket client.</p>
</dd>
<dt class="hdlist1">void ns_send_websocket_frame(struct ns_connection *nc, int op, const void *data, size_t data_len)</dt>
<dd>
<p>Send websocket frame to the remote end. <code>op</code> specifies frame&#8217;s type , one of:</p>
<div class="ulist">
<ul>
<li>
<p>WEBSOCKET_OP_CONTINUE</p>
</li>
<li>
<p>WEBSOCKET_OP_TEXT</p>
</li>
<li>
<p>WEBSOCKET_OP_BINARY</p>
</li>
<li>
<p>WEBSOCKET_OP_CLOSE</p>
</li>
<li>
<p>WEBSOCKET_OP_PING</p>
</li>
<li>
<p>WEBSOCKET_OP_PONG
<code>data</code> and <code>data_len</code> contain frame data.</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
<div class="paragraph">
<p>void ns_send_websocket_framev(struct ns_connection *nc, int op, const struct ns_str *frames, int num_frames);
  Send multiple websocket frames. Like <code>ns_send_websocket_frame()</code>, but sends
  multiple frames at once.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">void ns_printf_websocket_frame(struct ns_connection *nc, int op, const char *fmt, &#8230;&#8203;)</dt>
<dd>
<p>Send websocket frame to the remote end. Like <code>ns_send_websocket_frame()</code>,
but allows to create formatted message with <code>printf()</code>-like semantics.</p>
</dd>
<dt class="hdlist1">struct ns_str *ns_get_http_header(struct http_message *, const char *)</dt>
<dd>
<p>Returns HTTP header if it is present in the HTTP message, or <code>NULL</code>.</p>
</dd>
<dt class="hdlist1">int ns_parse_http(const char *s, int n, struct http_message *req)</dt>
<dd>
<p>Parses HTTP message. Return number of bytes parsed. If HTTP message is
incomplete, <code>0</code> is returned. On parse error, negative number is returned.</p>
</dd>
<dt class="hdlist1">int ns_get_http_var(const struct ns_str *buf, const char *name, char *dst, size_t dst_len)</dt>
<dd>
<p>Fetch an HTTP form variable <code>name</code> from a <code>buf</code> into a buffer specified by
<code>dst</code>, <code>dst_len</code>. Destination is always zero-terminated. Return length
of a fetched variable. If not found, 0 is returned. <code>buf</code> must be
valid url-encoded buffer. If destination is too small, <code>-1</code> is returned.</p>
</dd>
<dt class="hdlist1">void ns_serve_http(struct ns_connection *nc, struct http_message *request, struct ns_serve_http_opts options)</dt>
<dd>
<p>Serve given HTTP request according to the <code>options</code>.
Example code snippet:</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="title">web_server.c</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-c" data-lang="c">static void ev_handler(struct ns_connection *nc, int ev, void *ev_data) {
  struct http_message *hm = (struct http_message *) ev_data;
  struct ns_serve_http_opts opts = { .document_root = "/var/www" };  // C99 syntax

  switch (ev) {
    case NS_HTTP_REQUEST:
      ns_serve_http(nc, hm, opts);
      break;
    default:
      break;
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_json_rpc_api">JSON-RPC API</h3>
<div class="paragraph">
<p>JSON-RPC module is implemented using
<a href="https://github.com/cesanta/frozen">Frozen JSON parser/generator</a>. So for
JSON-related functionality refer to Frozen documentation.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">int ns_rpc_parse_reply(const char *buf, int len, struct json_token *toks, int max_toks, struct ns_rpc_reply *reply, struct ns_rpc_error *error)</dt>
<dd>
<p>Parse JSON-RPC reply contained in <code>buf</code>, <code>len</code> into JSON tokens array
<code>toks</code>, <code>max_toks</code>. If buffer contains valid reply, <code>reply</code> structure is
populated. The result of RPC call is located in <code>reply.result</code>. On error,
<code>error</code> structure is populated. Returns: the result of calling
<code>parse_json(buf, len, toks, max_toks)</code>.</p>
</dd>
<dt class="hdlist1">int ns_rpc_create_request(char *buf, int len, const char *method, const char *id, const char *params_fmt, &#8230;&#8203;)</dt>
<dd>
<p>Create JSON-RPC request in a given buffer. Return length of the request, which
can be larger then <code>len</code> that indicates an overflow.</p>
</dd>
<dt class="hdlist1">int ns_rpc_create_reply(char *buf, int len, const struct ns_rpc_request *req, const char *result_fmt, &#8230;&#8203;)</dt>
<dd>
<p>Create JSON-RPC reply in a given buffer. Return length of the reply, which
can be larger then <code>len</code> that indicates an overflow.</p>
</dd>
<dt class="hdlist1">int ns_rpc_create_error(char *, int, struct ns_rpc_request *req, int, const char *, const char *, &#8230;&#8203;)</dt>
<dd>
<p>Create JSON-RPC error in a given buffer. Return length of the error, which
can be larger then <code>len</code> that indicates an overflow.</p>
</dd>
<dt class="hdlist1">int ns_rpc_create_std_error(char *, int, struct ns_rpc_request *, int code)</dt>
<dd>
<p>Create JSON-RPC error in a given buffer. Return length of the error, which
can be larger then <code>len</code> that indicates an overflow. <code>code</code> could be one of:
<code>JSON_RPC_PARSE_ERROR</code>, <code>JSON_RPC_INVALID_REQUEST_ERROR</code>,
<code>JSON_RPC_METHOD_NOT_FOUND_ERROR</code>, <code>JSON_RPC_INVALID_PARAMS_ERROR</code>,
<code>JSON_RPC_INTERNAL_ERROR</code>, <code>JSON_RPC_SERVER_ERROR</code>.</p>
</dd>
<dt class="hdlist1">int ns_rpc_dispatch(const char *buf, int, char *dst, int dst_len, const char **methods, ns_rpc_handler_t *handlers)</dt>
<dd>
<p>Parses JSON-RPC request contained in <code>buf</code>, <code>len</code>. Then, dispatches the request
to the correct handler method. Valid method names should be specified in NULL
terminated array <code>methods</code>, and corresponding handlers in <code>handlers</code>.
Result is put in <code>dst</code>, <code>dst_len</code>. Return: length of the result, which
can be larger then <code>dst_len</code> that indicates an overflow.</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_mqtt_api">MQTT API</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">void ns_set_protocol_mqtt(struct ns_connection *)</dt>
<dd>
<p>Attach built-in MQTT event handler to the given connection. User-defined
event handler will receive following extra events:</p>
<div class="ulist">
<ul>
<li>
<p>NS_MQTT_CONNACK</p>
</li>
<li>
<p>NS_MQTT_PUBLISH</p>
</li>
<li>
<p>NS_MQTT_PUBACK</p>
</li>
<li>
<p>NS_MQTT_PUBREC</p>
</li>
<li>
<p>NS_MQTT_PUBREL</p>
</li>
<li>
<p>NS_MQTT_PUBCOMP</p>
</li>
<li>
<p>NS_MQTT_SUBACK</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">void ns_send_mqtt_handshake(struct ns_connection *, const char *)</dt>
<dd>
<p>Send MQTT handshake</p>
</dd>
<dt class="hdlist1">void ns_mqtt_publish(struct ns_connection *, const char *, uint16_t, int, const void *, size_t)</dt>
<dd>
<p>Publish message to a given channel</p>
</dd>
<dt class="hdlist1">void ns_mqtt_subscribe(struct ns_connection *, const struct ns_mqtt_topic_expression *, size_t, uint16_t)</dt>
<dd>
<p>Subscribe to a given channel</p>
</dd>
</dl>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2014-11-12 13:54:13 GMT
</div>
</div>
</body>
</html>